* FSP interrupts

  FSP interrupts are the interrupts generated by the FSP on various
  events such as availability of console chars, completion of RTC
  or NVRAM requests, etc...

  Under OPAL v1 and OPAL v2, a call to opal_poll_events() can
  effectively "consume" FSP interrupts. Thus, if one CPU is waiting
  for an RTC command to complete by waiting for an interrupt, while
  another CPU is calling opal_poll_events() to flush console output
  for example, then the first CPU might end up waiting forever as
  the interrupt could have been "consumed" by the call to
  opal_poll_events() done by the second CPU.

  This has been addressed in Sapphire. While the underlying FSP
  messages are still consumed, the interrupt line is left pending
  until opal_handle_interrupt() is called.

  Thus in the above scenario, an OPAL interrupt would have still
  occurred, allowing a wakeup of the CPU waiting for the RTC message
  completion, which can then inspect the latest OPAL event mask to
  decide whether this was the expected completion.

  The event mask will still be updated by the call to
  opal_poll_events() but we guarantee at least one interrupt will
  eventually occur.

  Linux doesn't currently make use of OPAL interrupts due to the above
  limitation, it is expected that this will change to take advantage
  of that new functionality.

  TODO: We need to advertize this via the device-tree

* RTC commands

  The relationship between those commands and the respective event
  bits returned by either opal_poll_events() and
  opal_handle_interrupt() has never been clarified by the
  spec. Additionally, there is no guarantee that an interrupt will be
  generated by either of those commands.

  Linux doesn't currently use either events or interrupts but simply
  calls the functions in a loop as long as they return either
  OPAL_BUSY or OPAL_BUSY_EVENT, additionally calling opal_poll_event()
  in the latter case.

  With Sapphire, those functions are always asynchronous and behave as
  follow:
  
    - The first call always returns OPAL_BUSY_EVENT (or an error)

    - When the operation is complete, an interrupt is generated and
      the corresponding event bit is *set*. The OS thus should either
      have interrupts enabled (and call opal_handle_interrupt()
      appropriately) or call opal_poll_events() in a loop until the
      event bit is set.

    - Any call to the corresponding function while the operation is
      still in progress will simply return OPAL_BUSY_EVENT

    - One the operation has completed (and the event bit is set), a
      last call to the corresponding function must be done to complete
      the operation. This last call will clear the pending event bit
      and, in the case of a "read" style operation, will return the
      appropriate response.

   TODO: Advertize this behaviour in the device-tree

   TODO: Define a specific status to request a retry due to a loss
         of FSP communication (or a reset/reload)

* NVRAM commands

  opal_read_nvram() always returns immediately. The nvram is
  read at boot and cached in memory. Writes update that image
  immediately as well but then trigger an asynchronous
  writeback to the FSP (and always return an immediate success
  or error status).

  The nvram "event" will be set until that writeback is complete.

  Subsequent nvram writes will still update the memory image, whether
  a writeback is in progress or not. If a writeback is in progress, a
  new writeback will be triggered.

  TODO: Consider deferring writebacks to poweroff/reboot or an
  explicit new OPAL function... 


* PCI:
 
     Lots of planned changes to the reset * SHPC functions, still to
     be written.

